<!DOCTYPE html><html lang="zh-CN" data-theme="dark"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>02 Redis 进阶 | 林深时觉寒</title><meta name="keywords" content="redis"><meta name="author" content="Limor"><meta name="copyright" content="Limor"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#0d0d0d"><meta name="description" content="Redis.conf 详解启动的时候，就通过配置文件启动。  配置文件 uint 单位对大小写不敏感  包含（include），就好比 java 里面的 import。  网络 123bind 127.0.0.1 # 绑定的 ipprotected-mode yes  # 保护模式port 6379 # 端口设置 通用 General 12345678910111213deamonize yes">
<meta property="og:type" content="article">
<meta property="og:title" content="02 Redis 进阶">
<meta property="og:url" content="https://kangjia1324.github.io/08-Redis/03%20Redis%20%E8%BF%9B%E9%98%B6/index.html">
<meta property="og:site_name" content="林深时觉寒">
<meta property="og:description" content="Redis.conf 详解启动的时候，就通过配置文件启动。  配置文件 uint 单位对大小写不敏感  包含（include），就好比 java 里面的 import。  网络 123bind 127.0.0.1 # 绑定的 ipprotected-mode yes  # 保护模式port 6379 # 端口设置 通用 General 12345678910111213deamonize yes">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://kangjia1324.github.io/img/cover/3.jpg">
<meta property="article:published_time" content="2021-05-11T04:56:24.000Z">
<meta property="article:modified_time" content="2021-05-19T10:59:15.570Z">
<meta property="article:author" content="Limor">
<meta property="article:tag" content="redis">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://kangjia1324.github.io/img/cover/3.jpg"><link rel="shortcut icon" href="/img/toux1.jpg"><link rel="canonical" href="https://kangjia1324.github.io/08-Redis/03%20Redis%20%E8%BF%9B%E9%98%B6/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//fonts.googleapis.com" crossorigin=""/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":800},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '02 Redis 进阶',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2021-05-19 18:59:15'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
          const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
          const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
          const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

          if (t === undefined) {
            if (isLightMode) activateLightMode()
            else if (isDarkMode) activateDarkMode()
            else if (isNotSpecified || hasNoSupport) {
              const now = new Date()
              const hour = now.getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            window.matchMedia('(prefers-color-scheme: dark)').addListener(function (e) {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const fontSizeVal = saveToLocal.get('global-font-size')
    if (fontSizeVal !== undefined) {
      document.documentElement.style.setProperty('--global-font-size', fontSizeVal + 'px')
    }
    })(window)</script><link rel="stylesheet" href="/self/monokai-sublime.css"><meta name="generator" content="Hexo 5.4.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="author-avatar"><img class="avatar-img" src="/img/toux1.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">20</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">12</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">7</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 文章</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/tags/"><span> 标签</span></a></li><li><a class="site-page child" href="/categories/"><span> 分类</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/categories/%E8%BD%AF%E7%A1%AC%E4%BB%B6%E4%BD%BF%E7%94%A8/"><span> Toolkits</span></a></div><div class="menus_item"><a class="site-page" href="/categories/%E6%95%85%E4%BA%8B/"><span> 故事</span></a></div><div class="menus_item"><a class="site-page" href="/links/"><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/cover/3.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">林深时觉寒</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 文章</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/tags/"><span> 标签</span></a></li><li><a class="site-page child" href="/categories/"><span> 分类</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/categories/%E8%BD%AF%E7%A1%AC%E4%BB%B6%E4%BD%BF%E7%94%A8/"><span> Toolkits</span></a></div><div class="menus_item"><a class="site-page" href="/categories/%E6%95%85%E4%BA%8B/"><span> 故事</span></a></div><div class="menus_item"><a class="site-page" href="/links/"><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">02 Redis 进阶</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-05-11T04:56:24.000Z" title="发表于 2021-05-11 12:56:24">2021-05-11</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2021-05-19T10:59:15.570Z" title="更新于 2021-05-19 18:59:15">2021-05-19</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Redis/">Redis</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">6.3k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>21分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="02 Redis 进阶"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h2 id="Redis-conf-详解"><a href="#Redis-conf-详解" class="headerlink" title="Redis.conf 详解"></a>Redis.conf 详解</h2><p>启动的时候，就通过配置文件启动。</p>
<ol>
<li><p>配置文件 uint 单位对大小写不敏感</p>
</li>
<li><p>包含（include），就好比 java 里面的 import。</p>
</li>
<li><p>网络</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">bind</span> 127.0.0.1 <span class="hljs-comment"># 绑定的 ip</span><br>protected-mode yes  <span class="hljs-comment"># 保护模式</span><br>port 6379 <span class="hljs-comment"># 端口设置</span><br></code></pre></td></tr></table></figure></li>
<li><p>通用 General</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs bash">deamonize yes <span class="hljs-comment"># 以守护进程的方式运行，默认是 no，需要手动设置为 yes</span><br><br>pidfile /var/run/redis_6379.pid  <span class="hljs-comment"># 如果以后台的方式运行，需要指定一个pid 文件</span><br><br><span class="hljs-comment"># 日志</span><br><span class="hljs-comment"># debug (a lot of information, useful for development/testing)</span><br><span class="hljs-comment"># verbose (many rarely useful info, but not a mess like the debug level)</span><br><span class="hljs-comment"># notice (moderately verbose, what you want in production probably)</span><br><span class="hljs-comment"># warning (only very important / critical messages are logged)</span><br>loglevel notice<br>logfile <span class="hljs-string">&quot;&quot;</span>  <span class="hljs-comment"># 日志的文件位置名</span><br>databases 16 <span class="hljs-comment"># 数据库数量，默认 16 个数据库</span><br>always-show-logo yes <span class="hljs-comment"># 是否显示 logo</span><br></code></pre></td></tr></table></figure></li>
<li><p>快照</p>
<p>持久化，在规定的时间内，执行了多少次操作，则会持久化到文件 .rdb .aof</p>
<p>redis 是内存数据库，如果没有持久化，那么断电即失</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 如果 900 内，至少有一个1 key 进行修改，我们即进行持久化操作</span><br>save 900 1<br><span class="hljs-comment"># 如果 300s内，如果至少有 10 个 key 进行了修改，我们即进行持久化操作</span><br>save 300 10<br><span class="hljs-comment"># 如果 60s内，如果至少 10000 key 进行了修改，我们即进行持久化操作</span><br>save 60 10000<br><br>stop-writes-on-bgsave-error yes <span class="hljs-comment"># 如果持久化出错，是否还需要继续工作</span><br>rdbcompression yes  <span class="hljs-comment"># 是否压缩 rdb 文件，需要消耗一些cpu 资源</span><br>rdbchecksum yes <span class="hljs-comment"># 保存 rdb 文件时，进行错误校验</span><br>dbfilename dump.rdb  <span class="hljs-comment"># rdb 文件名称</span><br>dir ./ <span class="hljs-comment"># rdb 文件保存目录</span><br></code></pre></td></tr></table></figure></li>
<li><p>replication  复制，主从复制有关</p>
</li>
<li><p>security 安全</p>
<p>​    我们可以在这里设置 redis 密码，默认是没有密码。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs bash">127.0.0.1:6379&gt; ping<br>PONG<br>127.0.0.1:6379&gt; config get requirepass  <span class="hljs-comment"># 获取 redis 的密码</span><br>1) <span class="hljs-string">&quot;requirepass&quot;</span><br>2) <span class="hljs-string">&quot;&quot;</span><br>127.0.0.1:6379&gt; config <span class="hljs-built_in">set</span> requirepass <span class="hljs-string">&quot;123456&quot;</span>  <span class="hljs-comment"># 设置 redis 的密码</span><br>OK<br>127.0.0.1:6379&gt; config get requirepass<br>1) <span class="hljs-string">&quot;requirepass&quot;</span><br>2) <span class="hljs-string">&quot;123456&quot;</span><br>127.0.0.1:6379&gt; <span class="hljs-built_in">exit</span><br>[root@VM_0_13_centos bin]<span class="hljs-comment"># redis-cli -p 6379</span><br>127.0.0.1:6379&gt; ping<br>(error) NOAUTH Authentication required.  <br>127.0.0.1:6379&gt; auth 123456  <span class="hljs-comment"># 使用密码登录</span><br>OK<br>127.0.0.1:6379&gt; ping<br>PONG<br></code></pre></td></tr></table></figure></li>
<li><p>Clients 客户端限制</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash">maxclients 10000 <span class="hljs-comment"># 设置最大连接上 redis 客户端数量</span><br>maxmemory &lt;byte&gt; <span class="hljs-comment"># Redis 配置最大的内存容量</span><br>maxmemory-policy noevition <span class="hljs-comment"># 内存达到上限之后的处理策略</span><br><span class="hljs-comment"># 当Redis所使用的内存达到 maxmemory 之后会触发相应的溢出控制策略，Redis支持 6 种策略：</span><br><span class="hljs-comment"># 1 noeviction：当内存使用达到阈值的时候，所有引起申请内存的命令会报错。</span><br><span class="hljs-comment"># 2 allkeys-lru：在所有键中采用lru算法删除键，直到腾出足够内存为止。</span><br><span class="hljs-comment"># 3 volatile-lru：在设置了过期时间的键中采用lru算法删除键，直到腾出足够内存为止。</span><br><span class="hljs-comment"># 4 allkeys-random：在所有键中采用随机删除键，直到腾出足够内存为止。</span><br><span class="hljs-comment"># 5 volatile-random：在设置了过期时间的键中随机删除键，直到腾出足够内存为止。</span><br><span class="hljs-comment"># 6 volatile-ttl：在设置了过期时间的键空间中，具有更早过期时间的key优先移除。</span><br></code></pre></td></tr></table></figure></li>
<li><p>append only 模式，aof 配置</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">appendonly no <span class="hljs-comment"># 默认不开启aof模式，默认使用 rdb方式持久化，大部分情况下 rdb完全够用</span><br>appendfilename <span class="hljs-string">&quot;appendonly.aof&quot;</span> <span class="hljs-comment"># 持久化文件的名字</span><br><br><span class="hljs-comment"># appendfsync always  # 每次修改都会 sync，消耗性能</span><br>appendfsync everysec <span class="hljs-comment"># 每秒执行一次 sync，可能丢失者 1s的数据</span><br><span class="hljs-comment"># appendfsync no # 不执行 sync，这时候操作系统自己同步数据，速度最快</span><br></code></pre></td></tr></table></figure></li>
</ol>
<h2 id="Redis-持久化"><a href="#Redis-持久化" class="headerlink" title="Redis 持久化"></a>Redis 持久化</h2><p>面试、工作，持久化都是重点。</p>
<p>Redis 是内存数据库，如果不能将内存中的数据库状态保存到磁盘，那么一旦服务器进程退出，服务器中的数据库状态也会消失。所以 Redis 提供了持久化功能。Redis 有两种不同的持久化方法，他们都可以以一种小而紧凑的格式将存储在内存中的数据写入硬盘。</p>
<p>第一种为时间点转储（point-in-time dump），转储操作既可以在“指定时间段内有指定数量的写操作执行”这一条件被满足时执行，又可以通过调用两条转储的硬盘命令中的任何一条来执行；</p>
<p>第二种持久化的方法将所有修改了的数据库的命令写入一个只追加的文件里面，用户可以根据数据的重要程度，将只追加写入设置为从不同步、每秒同步一次或者每写入一个命令就同步一次。</p>
<h3 id="RDB"><a href="#RDB" class="headerlink" title="RDB"></a>RDB</h3><p>在指定的时间间隔内将内存中的数据快照写入磁盘（Snapshot 快照），它恢复时将快照文件直接读取到内存里。</p>
<p>Redis 会单独创建（fork）一个子进程来进行持久化，会将数据写入到一个临时文件中，待持久化进程都结束了，再i用这个临时文件替换上次持久化好的文件。整个过程中主进程是不进行任何 IO 操作的，确保了极高的性能。我们默认的就是 RDB，一般情况不需要修改这个配置。</p>
<p>rdb 保存的文件时 dump.rdb 都是在我们的配置文件中进行配置的。</p>
<p><strong>触发机制</strong></p>
<ol>
<li>save 的规则满足的情况下，会自动触发 rdb 规则</li>
<li>执行 flushall 命令，也会触发 RDB 规则</li>
<li>退出 redis，也会产生 dump.rdb 文件</li>
</ol>
<p><strong>如何恢复 rdb 文件</strong></p>
<ol>
<li><p>只需要将 dump.rdb 文件放到 redis 启动目录就可以，redis 启动的时候会自动检查 dump.rdb 恢复其中的数据。</p>
</li>
<li><p>查看需要存在的位置</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">config get dir<br><span class="hljs-string">&quot;dir&quot;</span><br><span class="hljs-string">&quot;/usr/local/bin&quot;</span> <span class="hljs-comment"># 如果这个目录下存在 dump.rdb ，启动就会自动恢复其中的数据</span><br></code></pre></td></tr></table></figure></li>
</ol>
<p><strong>优点：</strong></p>
<ol>
<li>适合大规模的数据恢复</li>
<li>如果你对数据的完整性要求不高</li>
</ol>
<p><strong>缺点：</strong></p>
<ol>
<li>需要一定的时间间隔进行操作！如果 redis 意外 宕机了，这个最后一次修改数据就没有了</li>
<li>fork 进程的时候，会占用一定的内存空间。</li>
</ol>
<h3 id="AOF"><a href="#AOF" class="headerlink" title="AOF"></a>AOF</h3><p>以日志的形式来记录每个写操作，读操作不记录。</p>
<p>将我们所有命令都记录下来，恢复的时候将所有命令重新执行一遍。默认是不开启的。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">appendonly yes  <span class="hljs-comment"># 开启 aof</span><br></code></pre></td></tr></table></figure>

<p>然后重启，redis 就生效了。</p>
<p>如果这个 AOF 文件有错位，这时候 redis 是启动不了的，需要修复这个 aof 文件。redis 提供了一个工具 <code>redis-check-aof --fix</code>。如果文件正常，重启就可以直接恢复了。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">appendonly no <span class="hljs-comment"># 默认不开启aof模式，默认使用 rdb方式持久化，大部分情况下 rdb完全够用</span><br>appendfilename <span class="hljs-string">&quot;appendonly.aof&quot;</span> <span class="hljs-comment"># 持久化文件的名字</span><br><br><span class="hljs-comment"># appendfsync always  # 每次修改都会 sync，消耗性能</span><br>appendfsync everysec <span class="hljs-comment"># 每秒执行一次 sync，可能丢失者 1s的数据</span><br><span class="hljs-comment"># appendfsync no # 不执行 sync，这时候操作系统自己同步数据，速度最快</span><br></code></pre></td></tr></table></figure>

<p><strong>重写规则说明：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">auto-aof-rewrite-percentage 100<br>auto-aof-rewrite-min-size 64mb<br></code></pre></td></tr></table></figure>

<p>如果 aof 文件大于 64mb，太大了，fork 一个新的进程来将我们的文件进行重写。</p>
<p><strong>优点：</strong></p>
<ol>
<li>每次修改都同步，文件的完整性更加好</li>
<li>每秒同步一次，可能丢失 1秒的数据</li>
<li>从不同步，效率最高的</li>
</ol>
<p><strong>缺点：</strong></p>
<ol>
<li>相对于数据文件来说，aof 远大于 rdb，修复的速度也比 rdb慢</li>
<li>AOF 运行效率比 rdb 慢，所以 redis 默认的是 rdb 持久化。</li>
</ol>
<h2 id="Redis-发布订阅"><a href="#Redis-发布订阅" class="headerlink" title="Redis 发布订阅"></a>Redis 发布订阅</h2><p>Redis 发布订阅（sub/pub）是一种消息通信模式。发送者发送消息，订阅者接收消息。微博、微信、关注系统！</p>
<p>Redis 客户端可以订阅任意数量的频道。</p>
<p>消息发送者</p>
<p>频道</p>
<p>消息订阅者</p>
<p><img src="https://cdn.jsdelivr.net/gh/kangjia1324/Figurebed@master/data/image-20210122105210220.png" alt="image-20210122105210220"></p>
<p><strong>命令</strong></p>
<table>
<thead>
<tr>
<th align="left">序号</th>
<th align="left">命令及描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td align="left">[PSUBSCRIBE pattern pattern …] 订阅一个或多个符合给定模式的频道。</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left">PUBSUB subcommand [argument [argument …]] 查看订阅与发布系统状态。</td>
</tr>
<tr>
<td align="left">3</td>
<td align="left">PUBLISH channel message 将信息发送到指定的频道。</td>
</tr>
<tr>
<td align="left">4</td>
<td align="left">PUNSUBSCRIBE [pattern [pattern …]] 退订所有给定模式的频道。</td>
</tr>
<tr>
<td align="left">5</td>
<td align="left">[SUBSCRIBE channel channel …] 订阅给定的一个或多个频道的信息。</td>
</tr>
<tr>
<td align="left">6</td>
<td align="left">UNSUBSCRIBE [channel [channel …]] 指退订给定的频道。</td>
</tr>
</tbody></table>
<p><strong>测试：</strong></p>
<p>订阅端：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash">127.0.0.1:6379&gt; SUBSCRIBE kangjia  <span class="hljs-comment"># 订阅一个频道 kangjia</span><br>Reading messages... (press Ctrl-C to quit)<br>1) <span class="hljs-string">&quot;subscribe&quot;</span><br>2) <span class="hljs-string">&quot;kangjia&quot;</span><br>3) (<span class="hljs-built_in">integer</span>) 1<br><span class="hljs-comment"># 等待读取推送消息</span><br>1) <span class="hljs-string">&quot;message&quot;</span>  <span class="hljs-comment"># 消息</span><br>2) <span class="hljs-string">&quot;kangjia&quot;</span> <span class="hljs-comment"># 来自哪个频道的消息</span><br>3) <span class="hljs-string">&quot;hello&quot;</span> <span class="hljs-comment"># 消息内容</span><br></code></pre></td></tr></table></figure>

<p>发送端：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">127.0.0.1:6379&gt; PUBLISH kangjia hello  <span class="hljs-comment"># 发布者发送消息到频道</span><br>(<span class="hljs-built_in">integer</span>) 1<br></code></pre></td></tr></table></figure>

<blockquote>
<p>原理：</p>
<p><img src="https://cdn.jsdelivr.net/gh/kangjia1324/Figurebed@master/data/image-20210122110101749.png" alt="image-20210122110101749"></p>
<p>使用场景：</p>
<ol>
<li>实时消息系统</li>
<li>实时聊天</li>
<li>订阅，关注系统都是可以的</li>
<li>稍微复杂的场景我们就会使用消息中间件 MQ</li>
</ol>
</blockquote>
<h2 id="Redis-主从复制"><a href="#Redis-主从复制" class="headerlink" title="Redis 主从复制"></a>Redis 主从复制</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>主从复制，是将一台 Redis 服务器的数据，复制到其它的 Redis 服务器。前者称为主节点（master），后者称为从节点（slave）；数据的复制是单向的，只能由主节点复制到从节点。Master 以写为主，Slave 以读为主。</p>
<p>默认情况下，每台 Redis 服务器都是主节点；且一个主节点可以有多个或者没有从节点，但是一个从节点只能有一个主节点。</p>
<p>主从复制的作用包括：</p>
<ol>
<li>数据冗余：主从复制实现了数据的热备份，是持久化之外的一种数据冗余方式</li>
<li>故障恢复：当主节点出现问题时，可以由从节点提供服务，实现快速的故障恢复；实际上是一种服务的冗余；</li>
<li>负载均衡：主从复制的基础上，配合读写分离，可以由主节点提供写服务，由从节点提供读服务（即写 Redis 数据时应用连接主节点，读 Redis 数据时应用连接从节点），分担服务器负载；尤其是在写少读多的场景下，通过多个从节点分担杜甫在，可以大大提高 Redis 服务器的并发量；</li>
<li>高可用基石：除以上作用外，主从复制还是哨兵和集群能够实施的基础，因此说主从复制是 Redis 高可用的基础。</li>
</ol>
<p>一般来说，要将 Redis 运用于工程项目中，只用一台 Redis 是万万不能的，原因如下：</p>
<ol>
<li>从结构上，单个 Redis 服务端会发生单点故障，并且一台服务器需要处理所有的请求负载，压力较大；</li>
<li>从容量上，单个 Redis 服务器内存容量有限，就算一台 Redis 服务器内存容量是 256 G，也不能将所有的内存用作 Redis 存储内存。一般来说，单台 Redis 最大使用内存不应该超过 20 G</li>
</ol>
<p>电商网站上的商品，一般都是一次上传，无数次浏览的，也就是读多写少。对于这种场景，我们可以使用如下架构：</p>
<p><img src="https://cdn.jsdelivr.net/gh/kangjia1324/Figurebed@master/data/image-20210122131623599.png" alt="image-20210122131623599"></p>
<p>主从复制，读写分离。一主二从！</p>
<h3 id="一主二从环境配置："><a href="#一主二从环境配置：" class="headerlink" title="一主二从环境配置："></a>一主二从环境配置：</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">info replication <span class="hljs-comment"># 查看当前库信息</span><br></code></pre></td></tr></table></figure>

<p>假设有三个 Redis 服务器，要配置成如下环境：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># host port</span><br>127.0.0.1 6379  <span class="hljs-comment"># 我们将它配置成主机 master</span><br>127.0.0.1 6380  <span class="hljs-comment"># 从机</span><br>127.0.0.1 6381  <span class="hljs-comment"># 从机</span><br></code></pre></td></tr></table></figure>

<p><strong>第一步：复制三个配置文件，然后修改对应信息</strong></p>
<ol>
<li>端口</li>
<li>pid 名字</li>
<li>log 文件名字</li>
<li>dump.rdb 名字</li>
</ol>
<p>修改完后，启动三个实例。</p>
<p><strong>第二步：配置一主二从</strong></p>
<p>默认情况下，每台 Redis 服务器都是主节点。我们只需配置从机即可。</p>
<p>在从机 127.0.0.1 6380、127.0.0.1 6381 上分别配置 </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">127.0.0.1:6380&gt; slaveof 127.0.0.1 6379<br>OK<br>127.0.0.1:6381&gt; slaveof 127.0.0.1 6379<br>OK<br></code></pre></td></tr></table></figure>

<p>到现在简单的一主二从就配置好了。</p>
<blockquote>
<p>上面的一主二从是在命令里配置的，不是永久的。</p>
<p>真实的主从配置应该在配置文件中配置。在从服务器的配置文件种配置：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">replicaof &lt;masterip&gt; &lt;masterport&gt;<br></code></pre></td></tr></table></figure>
</blockquote>
<p>主机可以写，从机只能读不能写。</p>
<p><strong>测试：</strong></p>
<p>主机断开，从机依旧连接到主机，但是不能写操作。这个时候主机连上了，从机依旧可以直接获取主机写的信息！</p>
<p>如果是使用命令行，来配置的主从，这个时候如果从机重启了，就会变回主机！只要变为从机，立马就会从主机中获取值。</p>
<blockquote>
<p><strong>复制原理：</strong></p>
<p>Slave 启动成功连接到 master 后会发送一个 sync 命令</p>
<p>master 接到命令，启动后台的存盘进程，同时手机所有接收到的用于修改数据集命令，在后台执行完毕之后，master 将传送整个数据文件到 slave，并完成一次完全同步。</p>
<p>全量复制：slave 服务在接收到数据库文件数据后，将其存盘并加载到内存中。</p>
<p>增量复制：Master 继续将新的所有收集到的修改命令依次传递给 slave，完成同步</p>
<p>但是只要重新连接 master，一次完全同步（全量复制）将自动执行。</p>
</blockquote>
<h3 id="层层链路"><a href="#层层链路" class="headerlink" title="层层链路"></a>层层链路</h3><p><img src="https://cdn.jsdelivr.net/gh/kangjia1324/Figurebed@master/data/image-20210122133659799.png" alt="image-20210122133659799"></p>
<p>也可以完成我们的主从复制。</p>
<h3 id="手动配置"><a href="#手动配置" class="headerlink" title="手动配置"></a>手动配置</h3><p>如果主机断开了连接，我们可以使用 <code>slaceof no one</code> 让自己变成主机。其他节点就可以手动连接到这个最新的主节点。如果这时候老大修复了，那就重新连接。</p>
<h3 id="哨兵模式"><a href="#哨兵模式" class="headerlink" title="哨兵模式"></a>哨兵模式</h3><p>自动版切换老大的模式。</p>
<p>概述：</p>
<p>主从切换技术的方法是：当主服务器宕机后，需要手动把一台从服务器切换为主服务器，这就需要人工干预，费时费力，还会造成一段时间内服务不可用，这是不推荐使用的方式。更多时候我们选择哨兵模式。</p>
<p>哨兵模式能够后台监控主机是否故障，如果故障了根据投票自动将从库转换为主库。</p>
<p>哨兵模式是一种特殊的模式，首先 Redis 提供了哨兵的命令，哨兵是一个独立的进程，作为进程，它会独立运行。其原理是哨兵通过发送命令，等待 Redis 服务器响应，从而监控运行多个 Redis 实例。</p>
<p><img src="https://cdn.jsdelivr.net/gh/kangjia1324/Figurebed@master/data/image-20210122134556063.png" alt="image-20210122134556063"></p>
<p>这里的哨兵有两个作用：</p>
<ul>
<li>通过发送命令，让 Redis 服务器返回监控其运行状态，包括主服务器和从服务器</li>
<li>当哨兵检测到 master 宕机，会自动将 slave 切换成 master，然后通过 发布订阅模式 通知其他从服务器，修改配置文件，让它们切换主机。</li>
</ul>
<p>然后一个哨兵进程对 Redis 服务器进行监控，可能会出现问题，为此，我们可以使用多个哨兵进行监控，各个哨兵之间还会进行监控，这样就形成了多哨兵模式。</p>
<p><img src="https://cdn.jsdelivr.net/gh/kangjia1324/Figurebed@master/data/image-20210122134906631.png" alt="image-20210122134906631"></p>
<p>假设主服务器宕机，哨兵 1 先检测到这个结果，系统并不会马上进行 failover 过程，仅仅是哨兵1主观的认为主服务器不可用，这个现象成为主观下线。</p>
<p>当后面的哨兵也检测到主服务器不可用，并且数量达到一定值时，那么哨兵之间就会进行一次投票，投票的结果由一个哨兵发起，进行 failover【故障转移】操作。切换成功后，就会通过订阅发布模式，让各个哨兵把自己监控的从服务器实现切换主机，这个过程称为客观下线。</p>
<p>测试：</p>
<p>按照之前的一主二从环境</p>
<ol>
<li><p>在自定义的配置文件夹下新建 <code>my-redis-config</code> 配置哨兵配置文件 <code>sentinel.conf</code></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># sentinel monitor 被监控的名称 host port 1</span><br>sentinel monitor myredis 127.0.0.1 6379 1<br></code></pre></td></tr></table></figure>

<p>后面这个数字 1，代表主机挂了，slave 投票看谁接替成为主机。票数最多的将会成为新的主机。</p>
</li>
<li><p>启动哨兵</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">redis-sentinel my-redis-config/sentinel.conf<br></code></pre></td></tr></table></figure></li>
</ol>
<p>如果 Master 节点断开了，这个时候就会从从机中随机选择一个服务器！（这里面有一个投票算法）</p>
<p>如果主机回来了，只能归并到新的主机下，就当从机。</p>
<p>优点：</p>
<ol>
<li>哨兵集群，基于主从复制模式，所有的主从配置有点，它都有</li>
<li>主从可以切换，故障可以转移，系统可用性更好</li>
<li>哨兵模式其实就是主从模式的升级，手动到自动，更加健壮！</li>
</ol>
<p>缺点：</p>
<ol>
<li><p>Redis 不好在线扩容，集群容量一旦到达上限，在线扩容十分麻烦</p>
</li>
<li><p>实现哨兵模式的配置其实是很麻烦的，里面有很多选择</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># Example   sentinel.conf</span><br><span class="hljs-comment"># 哨兵sentinel实例运行的端口   默认是26379，如果有哨兵集群，我们还需要配置每个哨兵端口</span><br>port 26379<br><br><span class="hljs-comment">#哨兵sentinel的工作目录</span><br>dir /tmp<br><br><span class="hljs-comment">#哨兵 sentine1 监控的redis主节点的 ip port   </span><br><span class="hljs-comment"># master-name  ，可以自己命名的主节点名字 只能由字母A-Z、数字0-9、这三个字符&quot;  .   -  _ &quot;组成。</span><br><span class="hljs-comment"># quorum配置多少个sentine1哨兵统- -认为master主节点失联那么这时客观上认为主节点失联了</span><br><span class="hljs-comment"># sentine1 monitor &lt;master-name&gt; &lt;ip&gt; &lt;redis-port&gt; &lt;quorum&gt;</span><br>sentinel monitor mymaster   127.0.0.1   6379   2<br><br><span class="hljs-comment">#当在Redis实例中开启了requirepass foobared 授权密码这样所有连接kedis实例的客户端都要提供密码</span><br><span class="hljs-comment">#设置哨兵sentinel连接主从的密码注意必须为主从设置- - 样的验证密码</span><br><span class="hljs-comment"># sentine1 auth-pass &lt;master-name&gt; &lt;password&gt;</span><br>sentine1 auth-pass mymaster MySUPER--secret-0123passwOrd<br><br><span class="hljs-comment">#指定多少毫秒之后主节点没有应答哨兵sentine1 此时哨兵主观上认为主节点下线默认30秒</span><br><span class="hljs-comment"># sentinel down-after-mi 11i seconds &lt;master-name&gt; &lt;mi 11iseconds&gt;</span><br>sentine1 down-after-mi 11iseconds mymaster 30000<br><br><span class="hljs-comment">#这个配置项指定了在发生failover主备切换时最多可以有多少个slave同时对新的master进行同步，这个数字越小，完成fai lover所需的时间就越长，但是如果这个数字越大，就意味着越多的slave因为replication而 不可用。可以通过将这个值设为1来保证每次只有一个slave处于不能处理命令请求的状态。</span><br><span class="hljs-comment"># sentine1 paralle1-syncs &lt;master-name&gt; &lt;numslaves&gt;</span><br>sentine1 paralle1-syncs mymaster 1<br><br><span class="hljs-comment">#故障转移的超时时间failover-timeout 可以用在以下这些方面:</span><br><span class="hljs-comment">#1.同一个sentine1对同一 个master两次fai lover之间的间隔时间。</span><br><span class="hljs-comment">#2.当一个slave从一 个错误的master那里同步数据开始计算时间。直到s1ave被纠正为向正确的master那里同步数据时。</span><br><span class="hljs-comment">#3.当想要取消一个正在进行的failover所需要的时间。</span><br><span class="hljs-comment">#4.当进行failover时，配置所有s1aves指向新的master所需的最大时间。不过，即使过了这个超时，slaves 依然会被正确配置为指向master,但是就不按parallel-syncs所配置的规则来了</span><br><span class="hljs-comment">#默认三分钟</span><br><span class="hljs-comment"># sentine1 failover-timeout &lt;master-name&gt; &lt;milliseconds&gt;</span><br>sentine1 fai lover-ti meout mymaster 180000<br><br><span class="hljs-comment"># SCRIPTS EXECUTION</span><br><span class="hljs-comment">#配置当某一事件发生时所需要执行的脚本，可以通过脚本来通知管理员，例如当系统运行不正常时发邮件通知相关人员。</span><br><span class="hljs-comment">#对于脚本的运行结果有以下规则:</span><br><span class="hljs-comment">#若脚本执行后返回1，那么该脚本稍后将会被再次执行，重复次数目前默认为10</span><br><span class="hljs-comment">#若脚本执行后返回2，或者比2更高的一个返回值，脚本将不会重复执行。</span><br><span class="hljs-comment">#如果脚本在执行过程中由于收到系统中断信号被终止了，则同返回值为1时的行为相同。</span><br><span class="hljs-comment">#一个脚本的最大执行时间为60s，如果超过这个时间，脚本将会被-一个SIGKILL信号终止，之后重新执行。</span><br><br><span class="hljs-comment">#通知型脚本:当sentine1有任何警告级别的事件发生时(比如说redis实例的主观失效和客观失效等等)，将会去调用这个脚本，这时这个脚本应该通过邮件，SMS等 方式去通知系统管理员关于系统不正常运行的信息。调用该脚本时，将传给脚本两个参数，一 个是事件的类型，一个是事件的描述。如果sentine1. conf配置文件中配置了这个脚本路径，那么必须保证这个脚本存在于这个路径，并且是可执行的，否则sentine1无法正常启动成功。</span><br><span class="hljs-comment">#通知脚本</span><br><span class="hljs-comment"># she11编程</span><br><span class="hljs-comment"># sentine1 notification-script &lt;master-name&gt; &lt;script-path&gt;</span><br>sentine1 notificati on-script mymaster /var/redis/notify. sh<br><br><span class="hljs-comment">#客户端重新配置主节点参数脚本</span><br><span class="hljs-comment">#当一个master由于failover而发生改变时，这个脚本将会被调用，通知相关的客户端关于master地址已经发生改变的信息。</span><br><span class="hljs-comment">#以下参数将会在调用脚本时传给脚本: </span><br><span class="hljs-comment"># &lt;master-name&gt; &lt;role&gt; &lt;state&gt; &lt;from-ip&gt; &lt;from-port&gt; &lt;to-ip&gt; &lt;to-port&gt;</span><br><span class="hljs-comment">#目前&lt;state&gt;总是“failover&quot;,</span><br><span class="hljs-comment"># &lt;role&gt;是“Teader&quot;或者&quot;observer&quot;中的-一个。</span><br><span class="hljs-comment">#参数from-ip， from-port， to-ip，to-port是用来和旧的master和新的master(即旧的s lave)通信的</span><br><span class="hljs-comment">#这个脚本应该是通用的，能被多次调用，不是针对性的。</span><br><span class="hljs-comment"># sentine1 client-reconfig-script &lt;master-name&gt; &lt;script-path&gt;</span><br>sentine1 client-reconfig-script mymaster /var/redis/reconfig.sh <span class="hljs-comment">#一般都是由运维来配置!</span><br></code></pre></td></tr></table></figure></li>
</ol>
<h2 id="Redis-缓存穿透和雪崩"><a href="#Redis-缓存穿透和雪崩" class="headerlink" title="Redis 缓存穿透和雪崩"></a>Redis 缓存穿透和雪崩</h2><blockquote>
<p>面试高频、程序常用。</p>
</blockquote>
<h3 id="缓存穿透（查不到）"><a href="#缓存穿透（查不到）" class="headerlink" title="缓存穿透（查不到）"></a>缓存穿透（查不到）</h3><p>概念：</p>
<p>用户想要查询一个数据，发现 Redis 内存数据库没有，也就是缓存没有命中，于是直接向持久层数据库查询。发现也没有，于是本次查询失败。当用户很多的时候，缓存都没有命中（秒杀），于是都去请求了持久层数据库。这会给持久层数据库造成很大的压力，这时候就相当于出现了缓存穿透。</p>
<p>解决方案：</p>
<p><strong>布隆过滤器</strong></p>
<p>布隆过滤器是一种数据结构，对所有可能查询的参数以 hash 形式存储，在控制层先进行校验，不符合直接丢弃，从而避免了对底层存储系统的查询压力。</p>
<p><img src="https://cdn.jsdelivr.net/gh/kangjia1324/Figurebed@master/data/image-20210122141907239.png" alt="image-20210122141907239"></p>
<p><strong>缓存空对象</strong></p>
<p>当存储层不命中后，即使返回的空对象也将其缓存起来，同时设置一个过期时间，之后再访问这个数据就会从缓存中获取，保护了后端数据源。</p>
<p><img src="https://cdn.jsdelivr.net/gh/kangjia1324/Figurebed@master/data/image-20210122141540525.png" alt="image-20210122141540525"></p>
<p>但是这种方法会存在两个问题：</p>
<ol>
<li>如果空值被缓存起来，这就意味着缓存更多的空间存储更多的键，因为这当中可能会有更多的空值的键。</li>
<li>即使对空值设置了过期时间，但是会存在缓存层和存储层的数据会有一段时间窗口的不一致，这对于需要保持一致性的业务会有影响。</li>
</ol>
<h3 id="缓存击穿（量太大，缓存过期）"><a href="#缓存击穿（量太大，缓存过期）" class="headerlink" title="缓存击穿（量太大，缓存过期）"></a>缓存击穿（量太大，缓存过期）</h3><p>微博服务器宕机</p>
<p>概念：</p>
<p>这里需要注意和缓存击穿的区别，缓存击穿，是指一个 key 非常热点，在不停的扛着大并发，大并发集中对这一个点进行访问，当这个 key 在失效的瞬间，持续的大并发就会穿破缓存，直接请求数据库，就像在屏障上凿开了一个洞。</p>
<p>当某个 key 过期的瞬间，会有大量的请求并发访问，这种数据一般是热点数据，由于缓存过期，会同时访问数据库来查询最新数据，并且回写缓存，会导致数据库要瞬间过大。</p>
<p>解决方案：</p>
<p><strong>设置让热点数据永不过期</strong></p>
<p>从缓存层面来看，没有设置过期时间，所以不会出现热点 key 过期后产生的问题。</p>
<p><strong>加互斥锁</strong></p>
<p>分布式锁：使用分布式锁，保证对于每个 key，同时只有一个线程去查询后端服务，其他线程没有获得分布式锁的权限，因此只需要等待即可。这种方式将高并发的压力转移到了分布式锁，因此堆分布式锁的考验很大。</p>
<h3 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h3><p>概念</p>
<p>缓存雪崩，指的是在某一个时间段，缓存集中过期失效、或者是 Redis 宕机！</p>
<p><img src="https://cdn.jsdelivr.net/gh/kangjia1324/Figurebed@master/data/image-20210122142335304.png" alt="image-20210122142335304"></p>
<p>解决方案</p>
<p><strong>Redis 高可用</strong></p>
<p>多增设几台 Redis，搭建集群。（异地多活）</p>
<p><strong>限流降级</strong></p>
<p>这个解决方案的思想是，在缓存失效后，通过加锁或者队列来控制读取数据库写缓存的线程数量。比如对某个 key 只允许一个线程查询数据和写缓存，其它线程等待。</p>
<p><strong>数据预热</strong></p>
<p>数据与热的含义是在正式部署之前，我先吧可能的数据预先访问一边，这样部分可能大量访问的数据就会加载到缓存中。在即将发生大并发访问签手动触发加载缓存不同的 key，设置不同的过期时间，让缓存失效的时间点尽量均匀。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">Limor</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://kangjia1324.github.io/08-Redis/03%20Redis%20%E8%BF%9B%E9%98%B6/">https://kangjia1324.github.io/08-Redis/03 Redis 进阶/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://kangjia1324.github.io" target="_blank">林深时觉寒</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/redis/">redis</a></div><div class="post_share"><div class="social-share" data-image="/img/cover/3.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button button--animated"><i class="fas fa-qrcode"></i> 打赏</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/img/wechat1.jpg" target="_blank"><img class="post-qr-code-img" src="/img/wechat1.jpg" alt="wechat"/></a><div class="post-qr-code-desc">wechat</div></li><li class="reward-item"><a href="/img/alipay1.jpg" target="_blank"><img class="post-qr-code-img" src="/img/alipay1.jpg" alt="alipay"/></a><div class="post-qr-code-desc">alipay</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/80-%E6%95%85%E4%BA%8B/%E9%82%A3%E4%B8%80%E5%B9%B4%EF%BC%8C%E6%88%91%E9%AB%98%E5%9B%9B/"><img class="prev-cover" src="/img/cover/3.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">那一年，我高四</div></div></a></div><div class="next-post pull-right"><a href="/08-Redis/02%20Redis%20%E5%9F%BA%E7%A1%80/"><img class="next-cover" src="/img/cover/27.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">01 Redis 基础</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span> 相关推荐</span></div><div class="relatedPosts-list"><div><a href="/08-Redis/01 Redis 安装/" title="00 Redis 安装"><img class="cover" src="/img/cover/2.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-05-09</div><div class="title">00 Redis 安装</div></div></a></div><div><a href="/08-Redis/02 Redis 基础/" title="01 Redis 基础"><img class="cover" src="/img/cover/27.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-05-10</div><div class="title">01 Redis 基础</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="card-info-avatar is-center"><img class="avatar-img" src="/img/toux1.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/><div class="author-info__name">Limor</div><div class="author-info__description">我是描述</div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">20</div></a></div><div class="card-info-data-item is-center"><a href="/tags/"><div class="headline">标签</div><div class="length-num">12</div></a></div><div class="card-info-data-item is-center"><a href="/categories/"><div class="headline">分类</div><div class="length-num">7</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/kangjia1324"><i class="fab fa-github"></i><span>GitHub</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/kangjia1324" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:2466267753@qq.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Redis-conf-%E8%AF%A6%E8%A7%A3"><span class="toc-number">1.</span> <span class="toc-text">Redis.conf 详解</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Redis-%E6%8C%81%E4%B9%85%E5%8C%96"><span class="toc-number">2.</span> <span class="toc-text">Redis 持久化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#RDB"><span class="toc-number">2.1.</span> <span class="toc-text">RDB</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AOF"><span class="toc-number">2.2.</span> <span class="toc-text">AOF</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Redis-%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85"><span class="toc-number">3.</span> <span class="toc-text">Redis 发布订阅</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Redis-%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6"><span class="toc-number">4.</span> <span class="toc-text">Redis 主从复制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A6%82%E5%BF%B5"><span class="toc-number">4.1.</span> <span class="toc-text">概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E4%B8%BB%E4%BA%8C%E4%BB%8E%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%EF%BC%9A"><span class="toc-number">4.2.</span> <span class="toc-text">一主二从环境配置：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B1%82%E5%B1%82%E9%93%BE%E8%B7%AF"><span class="toc-number">4.3.</span> <span class="toc-text">层层链路</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%8B%E5%8A%A8%E9%85%8D%E7%BD%AE"><span class="toc-number">4.4.</span> <span class="toc-text">手动配置</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%93%A8%E5%85%B5%E6%A8%A1%E5%BC%8F"><span class="toc-number">4.5.</span> <span class="toc-text">哨兵模式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Redis-%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F%E5%92%8C%E9%9B%AA%E5%B4%A9"><span class="toc-number">5.</span> <span class="toc-text">Redis 缓存穿透和雪崩</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F%EF%BC%88%E6%9F%A5%E4%B8%8D%E5%88%B0%EF%BC%89"><span class="toc-number">5.1.</span> <span class="toc-text">缓存穿透（查不到）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF%EF%BC%88%E9%87%8F%E5%A4%AA%E5%A4%A7%EF%BC%8C%E7%BC%93%E5%AD%98%E8%BF%87%E6%9C%9F%EF%BC%89"><span class="toc-number">5.2.</span> <span class="toc-text">缓存击穿（量太大，缓存过期）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9"><span class="toc-number">5.3.</span> <span class="toc-text">缓存雪崩</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/07-Mysql/sql/01%20%E6%9F%A5%E6%89%BE%E9%87%8D%E5%A4%8D%E6%95%B0%E6%8D%AE/" title="01 SQL学习之查找重复数据"><img src="/img/cover/3.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="01 SQL学习之查找重复数据"/></a><div class="content"><a class="title" href="/07-Mysql/sql/01%20%E6%9F%A5%E6%89%BE%E9%87%8D%E5%A4%8D%E6%95%B0%E6%8D%AE/" title="01 SQL学习之查找重复数据">01 SQL学习之查找重复数据</a><time datetime="2021-05-20T05:21:20.000Z" title="发表于 2021-05-20 13:21:20">2021-05-20</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/80-%E6%95%85%E4%BA%8B/%E5%B0%86%E9%AB%98%E4%B8%AD%E8%BF%87%E6%88%90%E4%BA%86%E8%AF%97/" title="将高中过成了诗"><img src="/img/cover/3.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="将高中过成了诗"/></a><div class="content"><a class="title" href="/80-%E6%95%85%E4%BA%8B/%E5%B0%86%E9%AB%98%E4%B8%AD%E8%BF%87%E6%88%90%E4%BA%86%E8%AF%97/" title="将高中过成了诗">将高中过成了诗</a><time datetime="2021-05-16T10:21:00.000Z" title="发表于 2021-05-16 18:21:00">2021-05-16</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/80-%E6%95%85%E4%BA%8B/%E9%82%A3%E4%B8%80%E5%B9%B4%EF%BC%8C%E6%88%91%E9%AB%98%E5%9B%9B/" title="那一年，我高四"><img src="/img/cover/3.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="那一年，我高四"/></a><div class="content"><a class="title" href="/80-%E6%95%85%E4%BA%8B/%E9%82%A3%E4%B8%80%E5%B9%B4%EF%BC%8C%E6%88%91%E9%AB%98%E5%9B%9B/" title="那一年，我高四">那一年，我高四</a><time datetime="2021-05-11T10:20:00.000Z" title="发表于 2021-05-11 18:20:00">2021-05-11</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/08-Redis/03%20Redis%20%E8%BF%9B%E9%98%B6/" title="02 Redis 进阶"><img src="/img/cover/3.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="02 Redis 进阶"/></a><div class="content"><a class="title" href="/08-Redis/03%20Redis%20%E8%BF%9B%E9%98%B6/" title="02 Redis 进阶">02 Redis 进阶</a><time datetime="2021-05-11T04:56:24.000Z" title="发表于 2021-05-11 12:56:24">2021-05-11</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/08-Redis/02%20Redis%20%E5%9F%BA%E7%A1%80/" title="01 Redis 基础"><img src="/img/cover/27.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="01 Redis 基础"/></a><div class="content"><a class="title" href="/08-Redis/02%20Redis%20%E5%9F%BA%E7%A1%80/" title="01 Redis 基础">01 Redis 基础</a><time datetime="2021-05-10T04:56:24.000Z" title="发表于 2021-05-10 12:56:24">2021-05-10</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('/img/cover/3.jpg')"><div id="footer-wrap"><div class="copyright">&copy;2021 By Limor</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">Hi, welcome to my <a href="https://kangjia1324.github.io/">blog</a>!</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="font-plus" type="button" title="放大字体"><i class="fas fa-plus"></i></button><button id="font-minus" type="button" title="缩小字体"><i class="fas fa-minus"></i></button><button id="translateLink" type="button" title="简繁转换">简</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><div class="js-pjax"></div><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-nest.min.js"></script><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/click-heart.min.js" async="async" mobile="false"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>